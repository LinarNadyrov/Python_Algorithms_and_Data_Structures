#!/usr/bin/python3
# coding: utf-8

# Проанализировать скорость и сложность одного любого алгоритма из разработанных 
# в рамках домашнего задания первых трех уроков.
# Примечание. Идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать,
# b. написать 3 варианта кода (один у вас уже есть),
# c. проанализировать 3 варианта и выбрать оптимальный,
# d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, 
# для каких N вы проводили замеры),
# e. написать общий вывод: какой из трёх вариантов лучше и почему.

# В одномерном массиве целых чисел определить два наименьших элемента.
# Они могут быть как равны между собой (оба являться минимальными), так и различаться.
import timeit
import cProfile

array = [13, 12, 577, 124, 0, 1235, 98, -1, 1, 3, 999, -99]
# [-29, 21, -43, 7, 15, 34]
# [-29, 15, 99]



## ВАРИАНТ №1
# pos1 = 0
# pos2 = 0
# for i, item in enumerate(array):
#     if item <= array[pos1]:
#         pos2 = pos1
#         pos1 = i
#     elif item <= array[pos2]:
#         pos2 = i
# print('Два наименьших числа:', array[pos1], ' и ', array[pos2])

## ВАРИАНТ №2
# min1 = min(array)
# array.remove(min1)
# min2 = min(array)
# if min1 == min2:
#     print('Наименьшее число: ', min1)
# else: 
#     print('Два наименьших числа: ', min1, ' и ', min2)

# Тест с помощью timeit 
# Массив из трех элементов
# 100 loops, best of 3: 0.0191 usec per loop - ВАРИАНТ №1
# 100 loops, best of 3: 0.0191 usec per loop - ВАРИАНТ №2
# 100 loops, best of 3: 0.0381 usec per loop - ВАРИАНТ №3

# Массив из шести элементов
# 100 loops, best of 3: 0.0286 usec per loop - ВАРИАНТ №1
# 100 loops, best of 3: 0.0215 usec per loop - ВАРИАНТ №2

# Массив из двенадцати элементов
# 100 loops, best of 3: 0.00954 usec per loop - ВАРИАНТ №1
# 100 loops, best of 3: 0.0286 usec per loop - ВАРИАНТ №2